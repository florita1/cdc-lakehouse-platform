apiVersion: batch/v1
kind: Job
metadata:
  name: ch-init-job
  namespace: clickhouse
  annotations:
    # Run this after the CHI is synced
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/sync-wave: "7"
    # For debugging, keep the job around by leaving this line commented.
    # When you're confident, you can uncomment so Argo cleans it up automatically:
    # argocd.argoproj.io/hook-delete-policy: BeforeHookCreation,HookSucceeded,HookFailed
spec:
  backoffLimit: 0
  activeDeadlineSeconds: 600
  ttlSecondsAfterFinished: 600
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: init
          image: curlimages/curl:8.10.1
          env:
            # Use either service â€” both exist in your cluster:
            # - chi-clickhouse-clickhouse-0-0.clickhouse.svc.cluster.local:8123  (per-host)
            # - clickhouse-clickhouse.clickhouse.svc.cluster.local:8123          (aggregate)
            - name: CH_HOST
              value: "clickhouse-clickhouse.clickhouse.svc.cluster.local:8123"
            # AFTER the first successful run, if you want to require auth, add:
            # - name: CH_USER
            #   value: "ingest"
            # - name: CH_PASS
            #   value: "ingest-pass"
          command: ["/bin/sh","-c"]
          args:
            - |
              set -euo pipefail

              echo "Waiting for ClickHouse HTTP at ${CH_HOST} ..."
              END=$((SECONDS+600))
              # If you enable auth later, add:  -u "${CH_USER}:${CH_PASS}" to both curls below.
              until curl -fsS "http://${CH_HOST}/?query=SELECT%201" >/dev/null 2>&1; do
                if [ ${SECONDS} -ge ${END} ]; then
                  echo "Timed out waiting for ClickHouse at ${CH_HOST}"
                  exit 1
                fi
                echo "still waiting..."; sleep 3
              done

              echo "Applying /init/init.sql ..."
              curl -fsS "http://${CH_HOST}/" --data-binary @/init/init.sql
              echo "Init SQL applied successfully."
          volumeMounts:
            - name: init-sql
              mountPath: /init
      volumes:
        - name: init-sql
          configMap:
            name: ch-init-sql
